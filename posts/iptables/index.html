<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Iptables explore, implement virtual IP - zhengxin</title><link rel=icon type=image/png href=https://raw.githubusercontent.com/zhengxinzx/images/main/20240303214631.png><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Explain the core concepts of iptables and demonstrate how to implement virtual IP using iptables."><meta property="og:image" content="https://raw.githubusercontent.com/zhengxinzx/images/main/20240303214631.png"><meta property="og:url" content="https://zhengxin.online/posts/iptables/"><meta property="og:site_name" content="zhengxin"><meta property="og:title" content="Iptables explore, implement virtual IP"><meta property="og:description" content="Explain the core concepts of iptables and demonstrate how to implement virtual IP using iptables."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-28T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-28T00:00:00+00:00"><meta property="article:tag" content="Networking"><meta property="article:tag" content="Kubernetes"><meta name=twitter:card content="summary"><meta name=twitter:title content="Iptables explore, implement virtual IP"><meta name=twitter:description content="Explain the core concepts of iptables and demonstrate how to implement virtual IP using iptables."><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://zhengxin.online/css/main.cedbeeb0faeb84086f9984e91f32166984746a629a63df071897cc75ac92c4b7.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://zhengxin.online/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css disabled></head><body><div class=content><header><div class=main><a href=https://zhengxin.online/>zhengxin</a></div><nav><a href=/>Home</a>
<a href=/posts>Blogs</a>
<a href=/tags>Tags</a>
| <span id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://zhengxin.online/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Iptables explore, implement virtual IP</h1><div class=meta>Posted on Apr 28, 2024</div></div><section class=body><h2 id=what-is-netfilter>What is netfilter</h2><p>In 1999, the Linux kernel was augmented with <code>netfilter</code>, a robust framework designed to empower users with the capability to tailor network packet processing within kernel space. Netfilter introduces five pivotal hooks distributed at key stages of the network packet&rsquo;s journey, providing functionality ranging from packet filtering to network address translation. The hooks are as follows:</p><ul><li>PREROUTING</li><li>INPUT</li><li>FORWARD</li><li>OUTPUT</li><li>POSTROUTING</li></ul><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240428223704.png alt=20240428223704></p><p>Packets arriving at the host are processed through the <code>PREROUTING</code> -> <code>INPUT</code> sequence, while packets originating from the host follow the <code>OUTPUT</code> -> <code>POSTROUTING</code> path. Conversely, packets that are merely passing through the host, destined for another target, follow the <code>PREROUTING</code> -> <code>FORWARD</code> -> <code>POSTROUTING</code> trajectory.</p><p><code>Netfilter</code> empowers users with the ability to configure rules at each hook, providing granular control over network packet handling within a Linux host. For instance, users can set up a rule at the <code>INPUT</code> hook to filter out packets by dropping them if they originate from a specific IP address, effectively preventing the host from receiving any packets from that source.</p><blockquote><p>You can find more details about at the <a href=https://netfilter.org/>netfilter official website</a>.</p></blockquote><h2 id=what-is-iptables>What is iptables</h2><p>While <code>netfilter</code> provides the foundational framework within the kernel space, <code>iptables</code> is the complementary user-space utility that enables users to establish and manage the rules for each <code>netfilter</code> hook. True to its name, iptables organizes these rules into specific categories known as tables, which represent different types of packet processing functionalities. These tables include:</p><ul><li><code>filter</code>: The default table, which is used to filter the packet.</li><li><code>nat</code>: The table that is used to modify the source or destination IP address and port of the packet.</li><li><code>mangle</code>: The table that is used to modify the packet header.</li><li><code>raw</code>: The table that is used to configure the rules for the connection tracking.</li></ul><p>Within each table in <code>iptables</code>, there are several default chains that correspond to the <code>netfilter</code> hooks. For instance, the <code>filter</code> table contains the <code>INPUT</code>, <code>OUTPUT</code>, and <code>FORWARD</code> chains. These predefined chains mirror the packet processing stages managed by the hooks in <code>netfilter</code>. Users can modify the behavior of packet processing by appending or inserting rules into these chains, as demonstrated by the subsequent shell command.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ iptables -t filter -L
</span></span><span style=display:flex><span>Chain INPUT <span style=color:#666>(</span>policy ACCEPT<span style=color:#666>)</span>
</span></span><span style=display:flex><span>target     prot opt <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain FORWARD <span style=color:#666>(</span>policy ACCEPT<span style=color:#666>)</span>
</span></span><span style=display:flex><span>target     prot opt <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain OUTPUT <span style=color:#666>(</span>policy ACCEPT<span style=color:#666>)</span>
</span></span><span style=display:flex><span>target     prot opt <span style=color:#388038>source</span>               destination
</span></span></code></pre></div><p>This indicates that, the rules in <code>filter</code> table, which can accept or drop packets, can be applied in the <code>INPUT</code>, <code>OUTPUT</code>, and <code>FORWARD</code> hook. For example, the following command will drop the packet from the IP <code>1.2.3.4</code> to the current host:</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ iptables -t filter -A INPUT -s 1.2.3.4 -j DROP
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$ iptables -t filter -vnL
</span></span><span style=display:flex><span>Chain INPUT <span style=color:#666>(</span>policy ACCEPT <span style=color:#444>0</span> packets, <span style=color:#444>0</span> bytes<span style=color:#666>)</span>
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>    <span style=color:#444>0</span>     <span style=color:#444>0</span> DROP       all  --  *      *       1.2.3.4              0.0.0.0/0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain FORWARD <span style=color:#666>(</span>policy ACCEPT <span style=color:#444>0</span> packets, <span style=color:#444>0</span> bytes<span style=color:#666>)</span>
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain OUTPUT <span style=color:#666>(</span>policy ACCEPT <span style=color:#444>0</span> packets, <span style=color:#444>0</span> bytes<span style=color:#666>)</span>
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     <span style=color:#388038>source</span>               destination
</span></span></code></pre></div><p><code>Netfilter</code> hooks are selectively available across different <code>iptables</code> tables because not all hooks are applicable to the functions of each table. For instance, the <code>PREROUTING</code> hook is absent in the <code>filter</code> table, as the <code>filter</code> table is intended to examine packets after a routing decision has been made and is specifically focused on packets destined for the current host.</p><p>Incoming packets from external sources to the host follow a designated path:</p><ul><li>Hook: <code>PREROUTING</code><ul><li>Table: <code>raw</code>, chain: <code>PREROUTING</code></li><li>Table: <code>mangle</code>, chain: <code>PREROUTING</code></li><li>Table: <code>nat</code>, chain: <code>PREROUTING</code></li></ul></li><li>Hook: <code>INPUT</code><ul><li>Table: <code>mangle</code>, chain: <code>INPUT</code></li><li>Table: <code>filter</code>, chain: <code>INPUT</code></li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240428231117.png alt=20240428231117></p><p>For an outcoming packet from the current host to the outside, the packet will go through the path:</p><ul><li>Hook: <code>OUTPUT</code><ul><li>Table: <code>raw</code>, chain: <code>OUTPUT</code></li><li>Table: <code>mangle</code>, chain: <code>OUTPUT</code></li><li>Table: <code>nat</code>, chain: <code>OUTPUT</code></li><li>Table: <code>filter</code>, chain: <code>OUTPUT</code></li></ul></li><li>Hook: <code>POSTROUTING</code><ul><li>Table: <code>mangle</code>, chain: <code>POSTROUTING</code></li><li>Table: <code>nat</code>, chain: <code>POSTROUTING</code></li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240428231802.png alt=20240428231802></p><p>For an incoming packet from the outside, but target to another host, the Linux host can act as a router, to forward the request to that target host, the packet will go through the path:</p><ul><li>Hook: <code>PREROUTING</code><ul><li>Table: <code>raw</code>, chain: <code>PREROUTING</code></li><li>Table: <code>mangle</code>, chain: <code>PREROUTING</code></li><li>Table: <code>nat</code>, chain: <code>PREROUTING</code></li></ul></li><li>Hook: <code>FORWARD</code><ul><li>Table: <code>mangle</code>, chain: <code>FORWARD</code></li><li>Table: <code>filter</code>, chain: <code>FORWARD</code></li></ul></li><li>Hook: <code>POSTROUTING</code><ul><li>Table: <code>mangle</code>, chain: <code>POSTROUTING</code></li><li>Table: <code>nat</code>, chain: <code>POSTROUTING</code></li></ul></li></ul><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240428232340.png alt=20240428232340></p><p>In addition to the default chains, <code>iptables</code> allows users to create custom chains within each table to organize their rules more effectively. However, it&rsquo;s important to understand that these user-defined chains do not extend the functionality of <code>netfilter</code>; they serve organizational purposes only. For example, it&rsquo;s not possible to add a rule to the <code>PREROUTING</code> hook within the <code>filter</code> table through a custom chain, nor can additional hooks be introduced into the netfilter.</p><h2 id=demo-implement-virtual-ip>Demo: Implement virtual IP</h2><p>As a developer, you might have heard about <code>iptables</code> but never actually used it, leaving it to the realm of DevOps or SREs. However, with the shift towards cloud-native development, understanding tools like Kubernetes — the de facto standard for cloud-native applications — becomes crucial. iptables is one of the mechanisms Kubernetes uses to implement Services.</p><p>In Kubernetes, a Service acts as a virtual IP address for accessing a set of pods. This virtual IP doesn&rsquo;t belong to any individual pod; rather, requests to the virtual IP are distributed among the pods in the Service. In this demonstration, we&rsquo;ll replicate this functionality using iptables and Docker containers.</p><p>We have three containers: <em>client</em>, <em>server1</em>, and <em>server2</em>. From within the client container, we&rsquo;ll use iptables to set up a rule. This rule will forward requests destined for the virtual IP, <code>10.0.0.40</code>, to either <em>server1</em> or <em>server2</em> at random, mirroring the behavior of a Kubernetes Service.</p><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240430085312.png alt=20240430085312></p><p>First, lets create the network and containers.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#888;font-style:italic># Create a network with subnet 10.0.0.0/24</span>
</span></span><span style=display:flex><span>docker network create virtual_ip_demo --subnet<span style=color:#666>=</span>10.0.0.0/24
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Create a client container with IP 10.0.0.1/24</span>
</span></span><span style=display:flex><span>docker run -d --name client --network virtual_ip_demo --ip 10.0.0.10 --hostname client --cap-add NET_ADMIN antrea/toolbox tail -f /dev/null
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Create 2 servers with IP 10.0.0.2/24 and 10.0.0.3/24</span>
</span></span><span style=display:flex><span>docker run -d --name server1 --network virtual_ip_demo --ip 10.0.0.20 --hostname server1 strm/helloworld-http
</span></span><span style=display:flex><span>docker run -d --name server2 --network virtual_ip_demo --ip 10.0.0.30 --hostname server2 strm/helloworld-http
</span></span></code></pre></div><p>Now, let&rsquo;s attach into the client container and set up the iptables rule.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#888;font-style:italic># Attach into client container</span>
</span></span><span style=display:flex><span>docker <span style=color:#388038>exec</span> -it client sh
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># List chains in nat table</span>
</span></span><span style=display:flex><span>iptables -t nat -vnL
</span></span></code></pre></div><p>The output should be something like</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span> pkts bytes target     prot opt in     out     <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>    <span style=color:#444>0</span>     <span style=color:#444>0</span> DOCKER_OUTPUT  all  --  *      *       0.0.0.0/0            127.0.0.11
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain POSTROUTING <span style=color:#666>(</span>policy ACCEPT <span style=color:#444>0</span> packets, <span style=color:#444>0</span> bytes<span style=color:#666>)</span>
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>    <span style=color:#444>0</span>     <span style=color:#444>0</span> DOCKER_POSTROUTING  all  --  *      *       0.0.0.0/0            127.0.0.11
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER_OUTPUT <span style=color:#666>(</span><span style=color:#444>1</span> references<span style=color:#666>)</span>
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>    <span style=color:#444>0</span>     <span style=color:#444>0</span> DNAT       tcp  --  *      *       0.0.0.0/0            127.0.0.11           tcp dpt:53 to:127.0.0.11:38513
</span></span><span style=display:flex><span>    <span style=color:#444>0</span>     <span style=color:#444>0</span> DNAT       udp  --  *      *       0.0.0.0/0            127.0.0.11           udp dpt:53 to:127.0.0.11:40134
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Chain DOCKER_POSTROUTING <span style=color:#666>(</span><span style=color:#444>1</span> references<span style=color:#666>)</span>
</span></span><span style=display:flex><span> pkts bytes target     prot opt in     out     <span style=color:#388038>source</span>               destination
</span></span><span style=display:flex><span>    <span style=color:#444>0</span>     <span style=color:#444>0</span> SNAT       tcp  --  *      *       127.0.0.11           0.0.0.0/0            tcp spt:38513 to::53
</span></span><span style=display:flex><span>    <span style=color:#444>0</span>     <span style=color:#444>0</span> SNAT       udp  --  *      *       127.0.0.11           0.0.0.0/0            udp spt:40134 to::53
</span></span></code></pre></div><p>As you can see, Docker is also utilizing <code>iptables</code> to reroute DNS queries (port 53) to the DNS server it operates on the host. This is part of Docker&rsquo;s internal management to ensure containerized applications can resolve network addresses efficiently. Docker maintains this setup through custom chains, a best practice that keeps rules organized without directly modifying the built-in tables.</p><p>For the sake of simplicity in our demonstration, we&rsquo;ll bypass the creation of custom chains. Instead, we&rsquo;ll directly insert DNAT (Destination Network Address Translation) rules. These rules will redirect requests aimed at our virtual IP to either <code>server1</code> or <code>server2</code>, emulating the load-balancing feature of a Kubernetes Service.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#888;font-style:italic># Redirect packets destined for 10.0.0.40 to 10.0.0.20 with approximately 50% probability</span>
</span></span><span style=display:flex><span>iptables -t nat -A OUTPUT -d 10.0.0.40 -m statistic --mode random --probability 0.5 -j DNAT --to-destination 10.0.0.20
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Redirect packets destined for 10.0.0.40 to 10.0.0.30</span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># This rule will only be hit if the first rule does not match, approximating the other 50%</span>
</span></span><span style=display:flex><span>iptables -t nat -A OUTPUT -d 10.0.0.40 -j DNAT --to-destination 10.0.0.30
</span></span></code></pre></div><p>The initial rule we&rsquo;ve crafted leverages the <code>statistic</code> module to randomly direct traffic to our designated destination IP addresses. With the <code>--probability 0.5</code> flag, there&rsquo;s an even chance — specifically, a 50% likelihood — that a given packet will match this rule. Should the packet not match the first rule, it will then be evaluated against the subsequent rule, ensuring it gets redirected to <code>server2</code>.</p><p>To confirm the effectiveness of our virtual IP setup, we can continuously send requests to the virtual IP, <code>10.0.0.40</code>, and observe the distribution of traffic between <code>server1</code> and <code>server2</code>. This will demonstrate the load-balancing behavior akin to a Kubernetes Service.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#888;font-style:italic># Send request to 10.0.0.40 10 times</span>
</span></span><span style=display:flex><span><span style=color:#2838b0>for</span> i in <span style=color:#2838b0>$(</span>seq <span style=color:#444>1</span> 10<span style=color:#2838b0>)</span><span style=color:#888>;</span> <span style=color:#2838b0>do</span> curl 10.0.0.40<span style=color:#888>;</span> <span style=color:#2838b0>done</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server1&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server1&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server1&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server1&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server1&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server2&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server2&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server2&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server1&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span><span style=display:flex><span>&lt;html&gt;&lt;head&gt;&lt;title&gt;HTTP Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello from server2&lt;/h1&gt;&lt;/body&gt;&lt;/html
</span></span></code></pre></div><h2 id=exploring-further>Exploring further</h2><h2 id=exploring-further-1>Exploring Further</h2><p>The post presents a snapshot of <code>iptables</code> capabilities, especially in setting up a virtual IP. Should your curiosity be piqued and you&rsquo;re keen to delve deeper into the world of iptables, I highly suggest exploring additional materials to bolster your understanding:</p><ul><li>Dive into the comprehensive documentation and resources available at <a href=https://www.netfilter.org/>The netfilter.org project</a>, which is the home for the software behind iptables.</li><li>For a quick reference that you can keep at your fingertips, consider the <a href=https://www.oreilly.com/library/view/linux-iptables-pocket/9780596801861/>Linux iptables Pocket Reference</a> by O&rsquo;Reilly Media.</li><li>To understand the practical application of iptables in orchestrating containerized environments, read through insightful articles like <a href=https://dustinspecker.com/posts/iptables-how-kubernetes-services-direct-traffic-to-pods/>How Kubernetes Services Direct Traffic to Pods</a>, which breaks down the concepts into digestible examples.</li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/networking>Networking</a></li><li><a href=/tags/kubernetes>Kubernetes</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/zhengxinzx rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=mailto:xin.zheng.0459@outlook.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a></div><div class=footer-info>2024 © zhengxin | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script>feather.replace()</script></div></body></html>