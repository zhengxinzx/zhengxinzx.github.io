<!doctype html><html><head lang=en><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>Kubernetes networking: network namespace, veth pair and bridge - zhengxin</title><link rel=icon type=image/png href=https://raw.githubusercontent.com/zhengxinzx/images/main/20240303214631.png><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="This post will explain the fundamental concepts involved in Kubernetes networking, including network namespace, veth, and bridge."><meta property="og:image" content="https://raw.githubusercontent.com/zhengxinzx/images/main/20240303214631.png"><meta property="og:title" content="Kubernetes networking: network namespace, veth pair and bridge"><meta property="og:description" content="This post will explain the fundamental concepts involved in Kubernetes networking, including network namespace, veth, and bridge."><meta property="og:type" content="article"><meta property="og:url" content="https://zhengxin.online/posts/kubernetes_networking_1/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-04-06T00:00:00+00:00"><meta property="article:modified_time" content="2024-04-06T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Kubernetes networking: network namespace, veth pair and bridge"><meta name=twitter:description content="This post will explain the fundamental concepts involved in Kubernetes networking, including network namespace, veth, and bridge."><script src=https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js></script><link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel=stylesheet><link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://zhengxin.online/css/main.49cd757e8798937596a4b43c026a3fd1ba67aecebbe47d3940a4349b709dd62c.css><link id=darkModeStyle rel=stylesheet type=text/css href=https://zhengxin.online/css/dark.726cd11ca6eb7c4f7d48eb420354f814e5c1b94281aaf8fd0511c1319f7f78a4.css disabled></head><body><div class=content><header><div class=main><a href=https://zhengxin.online/>zhengxin</a></div><nav><a href=/>Home</a>
<a href=/posts>Blogs</a>
<a href=/tags>Tags</a>
| <span id=dark-mode-toggle onclick=toggleTheme()></span>
<script src=https://zhengxin.online/js/themetoggle.js></script></nav></header><main><article><div class=title><h1 class=title>Kubernetes networking: network namespace, veth pair and bridge</h1><div class=meta>Posted on Apr 6, 2024</div></div><section class=body><p>Kubernetes guarantees that each pod in the cluster has a unique IP address, and they can can communicate with each other using this IP address directly. You may wonder how this is achieved. We will have a series of posts that will explain how networking works in Kubernetes. And this is the first post in the series, which will explain three fundamental concepts: network namespace, veth, and bridge, that are the building blocks of Kubernetes (and container) networking.</p><p><em>In this post, we limit the discussion to the Linux networking, without considering the networking in other operating systems.</em></p><h2 id=what-are-network-namespaces>What are network namespaces?</h2><p>Network namespace can be considered as the backbone of container/Kubernetes networking. As its name suggests, namespace separate resources of a Linux system into multiple abstract isolated spaces. The network namespace isolates the network stack, including network devices, IP addresses, routing tables, etc. Each network namespace has its own network stack, and processes in different network namespaces cannot see each other&rsquo;s network stack.</p><p>A straight example is that in two separate network namespaces on same host, program can listen on the same port without conflict, as shown in figure below.</p><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240407191629.png alt=20240407191629></p><p>Network namespace can be created using the &ldquo;clone()&rdquo; system call with the &ldquo;CLONE_NEWNET&rdquo; flag. The <code>ip</code> command in the <code>iproute2</code> package provides a convenient way of creating and managing network namespaces using the <code>clone</code> system call. In this post, we will use the <code>ip</code> command to create network namespaces.</p><p>A network namespace can be created by</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Create a network namespace named ns1</span>
</span></span><span style=display:flex><span>$ sudo ip netns add ns1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># List the network namespaces</span>
</span></span><span style=display:flex><span>$ sudo ip netns list
</span></span><span style=display:flex><span>ns1
</span></span></code></pre></div><p>There will be a mount point <code>/var/run/netns/ns1</code> created when the network namespace <code>ns1</code> is created. The mount point exists for two reasons:</p><ul><li>It ease the network namespace management.</li><li>It allows the network namespace to exist even there is no process running in it.</li></ul><p>After a network namespace is created, we can use the <code>ip netns exec</code> command to execute a command in that namespace. The following command lists the network devices in the network namespace <code>ns1</code>. As you can see, the network namespace <code>ns1</code> has only the loopback interface <code>lo</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Check the network devices in ns1</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ip link show
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK&gt; mtu <span style=color:#444>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span></code></pre></div><p>As you may have noticed, the loopback interface <code>lo</code> is <code>DOWN</code>. Thus when we are trying to ping it, it will fail.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Ping the loopback interface in ns1</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ping 127.0.0.1
</span></span><span style=display:flex><span>ping: connect: Network is unreachable
</span></span></code></pre></div><p>This can be fixed by set the loopback interface <code>lo</code> up in the network namespace <code>ns1</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Set the loopback interface lo up in ns1</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ip link <span style=color:#388038>set</span> lo up
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Ping the loopback interface in ns1</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ping 127.0.0.1
</span></span><span style=display:flex><span>PING 127.0.0.1 <span style=color:#666>(</span>127.0.0.1<span style=color:#666>)</span> 56<span style=color:#666>(</span>84<span style=color:#666>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 127.0.0.1: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>1</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.015 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 127.0.0.1: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>2</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.054 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 127.0.0.1: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>3</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.052 ms
</span></span></code></pre></div><p>Before we move on to the next section, let&rsquo;s create another network namespace <code>ns2</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Create a network namespace named ns2</span>
</span></span><span style=display:flex><span>$ sudo ip netns add ns2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># List the network namespaces</span>
</span></span><span style=display:flex><span>$ sudo ip netns list
</span></span><span style=display:flex><span>ns2
</span></span><span style=display:flex><span>ns1
</span></span></code></pre></div><h2 id=what-are-veth-parirs>What are veth parirs?</h2><p>veth is short for &ldquo;virtual Ethernet&rdquo;. A veth pair is a pair of virtual network devices that are connected to each other. When a packet is sent to one end of the veth pair, it will be received by the other end. veth pairs are often used to connect network namespaces to the host network namespace or to connect two network namespaces.</p><p>A veth pair can be created using the <code>ip</code> command. The following command creates a veth pair named <code>veth1</code> and <code>veth2</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Create a veth pair veth1 and veth2</span>
</span></span><span style=display:flex><span>$ sudo ip link add veth1 <span style=color:#388038>type</span> veth peer name veth2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Set them up</span>
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth1 up
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth2 up
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># List the network devices</span>
</span></span><span style=display:flex><span>$ sudo ip link show
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style=color:#444>65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#444>1500</span> qdisc mq state UP mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/ether 00:15:5d:47:1d:09 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>3: veth2@veth1: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu <span style=color:#444>1500</span> qdisc noop state UP mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/ether 2e:a0:5d:4a:ff:85 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>4: veth1@veth2: &lt;BROADCAST,MULTICAST,M-DOWN&gt; mtu <span style=color:#444>1500</span> qdisc noop state UP mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/ether 86:0a:10:be:06:59 brd ff:ff:ff:ff:ff:ff
</span></span></code></pre></div><p>By default, the veth pairs are created in the default (host) namespace. We can move them to the network namespaces <code>ns1</code> and <code>ns2</code> respectively.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Move veth1 to ns1</span>
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth1 netns ns1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Check the network devices in ns1</span>
</span></span><span style=display:flex><span>sudo ip netns <span style=color:#388038>exec</span> ns1 ip link show
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style=color:#444>65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>4: veth1@if3: &lt;BROADCAST,MULTICAST&gt; mtu <span style=color:#444>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/ether 86:0a:10:be:06:59 brd ff:ff:ff:ff:ff:ff link-netns ns2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Move veth2 to ns2</span>
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth2 netns ns2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Check the network devices in ns2</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns2 ip link show
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK&gt; mtu <span style=color:#444>65536</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>3: veth2@if4: &lt;BROADCAST,MULTICAST&gt; mtu <span style=color:#444>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/ether 2e:a0:5d:4a:ff:85 brd ff:ff:ff:ff:ff:ff link-netns ns1
</span></span></code></pre></div><p>After the configuration above, the network architecture looks like the following figure.</p><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240407195114.png alt=20240407195114></p><p>We can assign IP address to the veth pairs in their respective network namespaces.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Assign IP address to veth1 in ns1</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ip addr add 10.0.0.1/24 dev veth1 <span style=color:#666>&amp;&amp;</span> sudo ip netns <span style=color:#388038>exec</span> ns1 ip link <span style=color:#388038>set</span> dev veth1 up
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Assign IP address to veth2 in ns2</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns2 ip addr add
</span></span></code></pre></div><p>From now on, the network namespace <code>ns1</code> and <code>ns2</code> can communicate with each other using the IP address assigned to the veth pairs.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Ping from ns1 to ns2</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ping 10.0.0.2
</span></span><span style=display:flex><span>PING 10.0.0.2 <span style=color:#666>(</span>10.0.0.2<span style=color:#666>)</span> 56<span style=color:#666>(</span>84<span style=color:#666>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.2: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>1</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.026 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.2: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>2</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.028 ms
</span></span></code></pre></div><p>So far, we have explained the network namespace and veth pair, and successfully connected two network namespaces. But what if there are more than two network namespaces? Should we create a veth pair for each pair of network namespaces? No, that&rsquo;s too cumbersome and unelgant. We can use a bridge to connect multiple network namespaces instead.</p><p>Before moving forward, let&rsquo;s clean the network namespaces and veth pairs created so far.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Clean the network namespaces</span>
</span></span><span style=display:flex><span>$ sudo ip netns del ns1
</span></span><span style=display:flex><span>$ sudo ip netns del ns2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Clean the veth pairs</span>
</span></span><span style=display:flex><span>$ sudo ip link del veth1
</span></span><span style=display:flex><span>$ sudo ip link del veth2
</span></span></code></pre></div><h2 id=what-is-a-bridge>What is a bridge?</h2><p>A bridge is a software component in the Linux kernel that simulates a network layer 2 switch. It can connect multiple network interfaces and forward packets between them, just like a &ldquo;bridge&rdquo;. It worth to note that a bridge cannot connect network interfaces on different hosts.</p><p>A bridge can be created using the <code>brctl</code> command in <code>bridge-utils</code> package. The following command creates a bridge named <code>br0</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Create a bridge named br0</span>
</span></span><span style=display:flex><span>$ sudo brctl addbr br0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Show the bridges</span>
</span></span><span style=display:flex><span>$ sudo brctl show
</span></span><span style=display:flex><span>bridge name     bridge id               STP enabled     interfaces
</span></span><span style=display:flex><span>br0             8000.1293e0c6f4b0       no
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># The bridge can be found in ip link show command as well</span>
</span></span><span style=display:flex><span>$ sudo ip link show
</span></span><span style=display:flex><span>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu <span style=color:#444>65536</span> qdisc noqueue state UNKNOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
</span></span><span style=display:flex><span>2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu <span style=color:#444>1500</span> qdisc mq state UP mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/ether 00:15:5d:47:1d:09 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>5: br0: &lt;BROADCAST,MULTICAST&gt; mtu <span style=color:#444>1500</span> qdisc noop state DOWN mode DEFAULT group default qlen <span style=color:#444>1000</span>
</span></span><span style=display:flex><span>    link/ether 12:93:e0:c6:f4:b0 brd ff:ff:ff:ff:ff:ff
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Turn on the bridge br0</span>
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> dev br0 up
</span></span></code></pre></div><p>Let&rsquo;s create 3 new network namespaces <code>ns1</code>, <code>ns2</code>, and <code>ns3</code>, with 3 new veth pairs <code>veth1_0, veth1_1</code>, <code>veth2_0, veth2_1</code>, and <code>veth3_0, veth3_1</code>. We will insert the <code>veth1_0</code>, <code>veth2_0</code>, and <code>veth3_0</code> into the bridge <code>br0</code>, and insert the <code>veth1_1</code>, <code>veth2_1</code>, and <code>veth3_1</code> into the network namespaces <code>ns1</code>, <code>ns2</code>, and <code>ns3</code> respectively.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Create network namespaces</span>
</span></span><span style=display:flex><span>$ sudo ip netns add ns1
</span></span><span style=display:flex><span>$ sudo ip netns add ns2
</span></span><span style=display:flex><span>$ sudo ip netns add ns3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Create veth pairs</span>
</span></span><span style=display:flex><span>$ sudo ip link add veth1_0 <span style=color:#388038>type</span> veth peer name veth1_1
</span></span><span style=display:flex><span>$ sudo ip link add veth2_0 <span style=color:#388038>type</span> veth peer name veth2_1
</span></span><span style=display:flex><span>$ sudo ip link add veth3_0 <span style=color:#388038>type</span> veth peer name veth3_1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Set them up</span>
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth1_0 up
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth1_1 up
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth2_0 up
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth2_1 up
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth3_0 up
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth3_1 up
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Insert veth1_0, veth2_0, and veth3_0 into the bridge br0</span>
</span></span><span style=display:flex><span>$ sudo brctl addif br0 veth1_0
</span></span><span style=display:flex><span>$ sudo brctl addif br0 veth2_0
</span></span><span style=display:flex><span>$ sudo brctl addif br0 veth3_0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Move veth1_1, veth2_1, and veth3_1 to ns1, ns2, and ns3 respectively</span>
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth1_1 netns ns1
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth2_1 netns ns2
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> veth3_1 netns ns3
</span></span><span style=display:flex><span><span style=color:#b83838>```</span>bash
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Then we add the IP address to th veth in the network namespaces.
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#b83838>```</span>bash
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Assign IP address to veth1_1 in ns1</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ip addr add 10.0.0.1/24 dev veth1_1
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ip link <span style=color:#388038>set</span> dev veth1_1 up
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Assign IP address to veth2_1 in ns2</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns2 ip addr add 10.0.0.2/24 dev veth2_1
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns2 ip link <span style=color:#388038>set</span> dev veth2_1 up
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Assign IP address to veth3_1 in ns3</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns3 ip addr add 10.0.0.3/24 dev veth3_1
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns3 ip link <span style=color:#388038>set</span> dev veth3_1 up
</span></span></code></pre></div><p>Now the network architecture looks like the following figure.</p><p><img src=https://raw.githubusercontent.com/zhengxinzx/images/main/picgo20240407202004.png alt=20240407202004></p><p>Then we can verify the connection between the network namespaces.</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Ping from ns1 to ns2</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ping 10.0.0.2
</span></span><span style=display:flex><span>PING 10.0.0.2 <span style=color:#666>(</span>10.0.0.2<span style=color:#666>)</span> 56<span style=color:#666>(</span>84<span style=color:#666>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.2: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>1</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.046 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.2: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>2</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.072 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.2: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>3</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.073 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Ping from ns1 to ns3</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns1 ping 10.0.0.3
</span></span><span style=display:flex><span>PING 10.0.0.3 <span style=color:#666>(</span>10.0.0.3<span style=color:#666>)</span> 56<span style=color:#666>(</span>84<span style=color:#666>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.3: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>1</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.044 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.3: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>2</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.076 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.3: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>3</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.076 ms
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Ping from ns2 to ns3</span>
</span></span><span style=display:flex><span>$ sudo ip netns <span style=color:#388038>exec</span> ns2 ping 10.0.0.3
</span></span><span style=display:flex><span>PING 10.0.0.3 <span style=color:#666>(</span>10.0.0.3<span style=color:#666>)</span> 56<span style=color:#666>(</span>84<span style=color:#666>)</span> bytes of data.
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.3: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>1</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.039 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.3: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>2</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.072 ms
</span></span><span style=display:flex><span><span style=color:#444>64</span> bytes from 10.0.0.3: <span style=color:#b04040>icmp_seq</span><span style=color:#666>=</span><span style=color:#444>3</span> <span style=color:#b04040>ttl</span><span style=color:#666>=</span><span style=color:#444>64</span> <span style=color:#b04040>time</span><span style=color:#666>=</span>0.067 ms
</span></span></code></pre></div><p>Cool! We have successfully connected three network namespaces using a bridge! This is the end of the post, and we have explained the fundamental concepts involved in Kubernetes networking, including network namespace, veth, and bridge. The resources created can be cleaned by</p><div class=highlight><pre tabindex=0 style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span><span style=color:#888;font-style:italic># Clean the network namespaces</span>
</span></span><span style=display:flex><span>$ sudo ip netns del ns1
</span></span><span style=display:flex><span>$ sudo ip netns del ns2
</span></span><span style=display:flex><span>$ sudo ip netns del ns3
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#888;font-style:italic># Clean the bridge</span>
</span></span><span style=display:flex><span>$ sudo ip link <span style=color:#388038>set</span> dev br0 down
</span></span><span style=display:flex><span>$ sudo brctl delbr br0
</span></span></code></pre></div><h2 id=whats-next>What&rsquo;s next?</h2><p>In the future posts, we will explain how Kubernetes networking works, including the CNI plugin, kube-proxy, and the service discovery mechanism. Stay tuned!</p></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/kubernetes>Kubernetes</a></li><li><a href=/tags/networking>Networking</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/zhengxinzx rel=me title=GitHub><i data-feather=github></i></a>
<a class=border></a><a class=soc href=mailto:xin.zheng.0459@outlook.com rel=me title=Mail><i data-feather=mail></i></a>
<a class=border></a></div><div class=footer-info>2024 Â© zhengxin |</div></footer><script>feather.replace()</script></div></body></html>